diff --git a/app/(dashboard)/dashboard/sea/page.tsx b/app/(dashboard)/dashboard/sea/page.tsx
index e4d7d9c27c8e32d477a7317781b025c8223d17db..7093ca9ee7c954d3f5f5c8b291b6239a0d2a8f05 100644
--- a/app/(dashboard)/dashboard/sea/page.tsx
+++ b/app/(dashboard)/dashboard/sea/page.tsx
@@ -13,50 +13,52 @@ interface AssignedSession {
   start_time: string;
   end_time: string;
   service_type: string;
   student_initials: string;
   student_grade: string;
   completed_at: string | null;
   session_notes: string | null;
 }

 export default function SEADashboard() {
   const [assignedSessions, setAssignedSessions] = useState<AssignedSession[]>([]);
   const [loading, setLoading] = useState(true);
   const [todaysSessions, setTodaysSessions] = useState<AssignedSession[]>([]);
   const supabase = createClientComponentClient();

   useEffect(() => {
     fetchSEAData();
   }, []);

   const fetchSEAData = async () => {
     try {
       const { data: { user } } = await supabase.auth.getUser();
       if (!user) throw new Error('Not authenticated');

       // Call the database function to get SEA sessions with student info
+      // `get_sea_assigned_sessions` is a Postgres RPC that returns the sessions
+      // assigned to the SEA user along with student details.
       const { data: sessions, error } = await supabase
         .rpc('get_sea_assigned_sessions', {
           sea_user_id: user.id
         });

       if (error) {
         console.error('Error fetching sessions:', error);
         setLoading(false);
         return;
       }

       // Transform the data from the RPC function
       const transformedSessions = (sessions || []).map(session => ({
         id: session.session_id,
         student_id: session.student_id,
         day_of_week: session.day_of_week,
         start_time: session.start_time,
         end_time: session.end_time,
         service_type: session.service_type,
         student_initials: session.student_initials || 'Unknown',
         student_grade: session.student_grade || '',
         completed_at: session.completed_at,
         session_notes: session.session_notes
       }));

diff --git a/lib/scheduling/auto-scheduler.ts b/lib/scheduling/auto-scheduler.ts
index 96245105470f3888bc32b60730d1d121b2f91d58..f7b0306c543e1654d0cb2fa6082aad75bd8ca9d0 100644
--- a/lib/scheduling/auto-scheduler.ts
+++ b/lib/scheduling/auto-scheduler.ts
@@ -1,58 +1,74 @@
 import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';
 import { Database } from '../../src/types/database';

+/**
+ * Utility class used to automatically generate schedule sessions for students.
+ *
+ * The scheduler creates 5 minute time slots between 8:00 AM and 2:30 PM and
+ * iterates through them trying to place each required session. Every slot is
+ * validated against bell schedules, special activities and existing sessions to
+ * ensure there are no conflicts and that only one session occurs per student
+ * each day.
+ */
+
 type Student = Database['public']['Tables']['students']['Row'];
 type BellSchedule = Database['public']['Tables']['bell_schedules']['Row'];
 type SpecialActivity = Database['public']['Tables']['special_activities']['Row'];
 type ScheduleSession = Database['public']['Tables']['schedule_sessions']['Row'];

 interface ScheduleSlot {
   dayOfWeek: number;
   startTime: string;
   endTime: string;
 }

 interface SchedulingResult {
   success: boolean;
   scheduledSessions: Omit<ScheduleSession, 'id' | 'created_at'>[];
   unscheduledStudents: Student[];
   errors: string[];
 }

 export class AutoScheduler {
   private supabase;
   private providerId: string;
   private providerRole: string;

   constructor(providerId: string, providerRole: string) {
     this.supabase = createClientComponentClient<Database>();
     this.providerId = providerId;
     this.providerRole = providerRole;
   }

-  // Main scheduling function for a single student
+  /**
+   * Attempts to schedule all required sessions for a single student.
+   *
+   * The method first calls {@link findAvailableSlots} to collect candidate time
+   * slots and then creates `schedule_sessions` rows for each valid slot until
+   * the student's weekly requirement is met.
+   */
   async scheduleStudent(
     student: Student,
     existingSessions: ScheduleSession[],
     bellSchedules: BellSchedule[],
     specialActivities: SpecialActivity[]
   ): Promise<SchedulingResult> {
     const result: SchedulingResult = {
       success: false,
       scheduledSessions: [],
       unscheduledStudents: [],
       errors: []
     };

     try {
       const sessionsNeeded = student.sessions_per_week;
       const sessionDuration = student.minutes_per_session;

       // Find the best slots for this student
       const availableSlots = await this.findAvailableSlots(
         student,
         sessionDuration,
         sessionsNeeded,
         existingSessions,
         bellSchedules,
         specialActivities
@@ -64,51 +80,57 @@ export class AutoScheduler {
       }

       // Create session objects for the available slots
       for (let i = 0; i < Math.min(availableSlots.length, sessionsNeeded); i++) {
         const slot = availableSlots[i];
         result.scheduledSessions.push({
           student_id: student.id,
           provider_id: this.providerId,
           day_of_week: slot.dayOfWeek,
           start_time: slot.startTime,
           end_time: slot.endTime,
           service_type: this.providerRole
         });
       }

       console.log(`Created ${result.scheduledSessions.length} sessions for ${student.initials}`);

       result.success = result.scheduledSessions.length === sessionsNeeded;
     } catch (error) {
       result.errors.push(`Error scheduling ${student.initials}: ${error.message}`);
     }

     return result;
   }

-  // Find available time slots for a student
+  /**
+   * Generates a set of potential schedule slots for a student.
+   *
+   * This method iterates over each weekday and possible start time produced by
+   * {@link generateTimeSlots}. Slots are validated using
+   * {@link validateSlot} and returned in the order they are found.
+   */
   private async findAvailableSlots(
     student: Student,
     duration: number,
     slotsNeeded: number,
     existingSessions: ScheduleSession[],
     bellSchedules: BellSchedule[],
     specialActivities: SpecialActivity[]
   ): Promise<ScheduleSlot[]> {
     console.log(`Finding ${slotsNeeded} slots of ${duration} minutes for student ${student.initials}`);

     const availableSlots: ScheduleSlot[] = [];
     const days = [1, 2, 3, 4, 5]; // Monday through Friday
     const timeSlots = this.generateTimeSlots();
     const scheduledForThisStudent: ScheduleSlot[] = [];

     // Try to distribute sessions across days evenly
     const sessionsByDay = this.countSessionsByDay(existingSessions);
     const sortedDays = days.sort((a, b) => (sessionsByDay[a] || 0) - (sessionsByDay[b] || 0));

     // NEW: Rotate through different starting times to distribute throughout the day
     let timeSlotStartIndex = existingSessions.length % timeSlots.length;

     // Simple single pass - one session per day rule makes this much simpler
     for (const day of sortedDays) {
       if (availableSlots.length >= slotsNeeded) break;
@@ -141,92 +163,110 @@ export class AutoScheduler {

         if (validation.valid) {
           const newSlot = {
             dayOfWeek: day,
             startTime,
             endTime
           };
           availableSlots.push(newSlot);
           scheduledForThisStudent.push(newSlot);
           console.log(`Found valid slot: Day ${day}, ${startTime}-${endTime}`);
           break; // Move to next day after finding one slot
         } else {
           console.log(`Invalid slot: Day ${day}, ${startTime}-${endTime} - Reason: ${validation.reason}`);
         }
       }
     }

     if (availableSlots.length < slotsNeeded) {
       console.log(`Only found ${availableSlots.length} of ${slotsNeeded} required slots`);
     }

     return availableSlots;
   }

   // Utility functions
+
+  /**
+   * Returns a list of start times from 8:00 AM to 2:30 PM in 5 minute
+   * increments. These serve as the potential beginning of a session.
+   */
   private generateTimeSlots(): string[] {
     const slots: string[] = [];
     // Generate slots every 5 minutes for maximum flexibility
     for (let hour = 8; hour <= 14; hour++) {
       for (let minute = 0; minute < 60; minute += 5) {
         // Don't go past 2:30 PM to leave buffer before 3 PM
         if (hour === 14 && minute > 30) break;
         slots.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
       }
     }
     return slots;
   }

+  /** Converts a HH:MM string into minutes since midnight. */
   private timeToMinutes(time: string): number {
     const [hours, minutes] = time.split(':').map(Number);
     return hours * 60 + minutes;
   }

+  /** Adds minutes to a time string and returns a HH:MM:SS value. */
   private addMinutesToTime(time: string, minutesToAdd: number): string {
     const totalMinutes = this.timeToMinutes(time) + minutesToAdd;
     const hours = Math.floor(totalMinutes / 60);
     const minutes = totalMinutes % 60;
     return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:00`;
   }

+  /**
+   * Checks if two time ranges overlap.
+   */
   private hasTimeOverlap(start1: string, end1: string, start2: string, end2: string): boolean {
     const start1Min = this.timeToMinutes(start1);
     const end1Min = this.timeToMinutes(end1);
     const start2Min = this.timeToMinutes(start2);
     const end2Min = this.timeToMinutes(end2);

     return !(end1Min <= start2Min || start1Min >= end2Min);
   }

+  /** Returns a map of day_of_week to count of sessions. */
   private countSessionsByDay(sessions: ScheduleSession[]): Record<number, number> {
     const counts: Record<number, number> = {};
     sessions.forEach(session => {
       counts[session.day_of_week] = (counts[session.day_of_week] || 0) + 1;
     });
     return counts;
   }

+  /**
+   * Checks if a potential slot violates any scheduling rules.
+   *
+   * Validates against bell schedules, teacher activities, existing sessions,
+   * the one-session-per-day rule and slot capacity. Returns a flag and optional
+   * reason when the slot is invalid.
+   */
   private validateSlot(
     student: Student,
     dayOfWeek: number,
     startTime: string,
     endTime: string,
     duration: number,
     existingSessions: ScheduleSession[],
     bellSchedules: BellSchedule[],
     specialActivities: SpecialActivity[],
     scheduledForThisStudent: ScheduleSlot[] = []
   ): { valid: boolean; reason?: string } {
     console.log(`Validating slot for ${student.initials}: Day ${dayOfWeek}, ${startTime}-${endTime} (${duration} min)`);

     // Check if session fits within school hours (before 3:00 PM)
     if (this.timeToMinutes(endTime) > this.timeToMinutes('15:00')) {
       return { valid: false, reason: 'Extends beyond school hours' };
     }

     // Check bell schedule conflicts
     const bellConflicts = bellSchedules.filter(bell => {
       const grades = bell.grade_level.split(',').map(g => g.trim());
       return grades.includes(student.grade_level.trim()) &&
              bell.day_of_week === dayOfWeek &&
              this.hasTimeOverlap(startTime, endTime, bell.start_time, bell.end_time);
     });
diff --git a/lib/supabase/queries/bell-schedules.ts b/lib/supabase/queries/bell-schedules.ts
index 17ba244a7ea5b59cf1bd0a34eede86934b7664c9..5335ed62af00b0f85b10da3e19c19375cddc38fb 100644
--- a/lib/supabase/queries/bell-schedules.ts
+++ b/lib/supabase/queries/bell-schedules.ts
@@ -1,73 +1,87 @@
 import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';
 import { Database } from '../../../src/types/database';

 type BellSchedule = Database['public']['Tables']['bell_schedules']['Insert'];

+/**
+ * Insert a new bell schedule for the authenticated provider.
+ * @param schedule - Schedule details excluding metadata fields.
+ * @returns The created bell schedule row.
+ */
 export async function addBellSchedule(schedule: Omit<BellSchedule, 'id' | 'created_at' | 'updated_at' | 'provider_id'>) {
   const supabase = createClientComponentClient<Database>();

   // CRITICAL: Get current user to set provider_id
   const { data: { user } } = await supabase.auth.getUser();
   if (!user) throw new Error('Not authenticated');

   const { data, error } = await supabase
     .from('bell_schedules')
     .insert([{
       ...schedule,
       provider_id: user.id // CRITICAL: Set provider_id explicitly
     }])
     .select()
     .single();

   if (error) throw error;
   return data;
 }

+/**
+ * Remove a bell schedule by id if it belongs to the current user.
+ */
 export async function deleteBellSchedule(id: string) {
   const supabase = createClientComponentClient<Database>();

   // CRITICAL: Get current user to verify ownership
   const { data: { user } } = await supabase.auth.getUser();
   if (!user) throw new Error('Not authenticated');

   const { error } = await supabase
     .from('bell_schedules')
     .delete()
     .eq('id', id)
     .eq('provider_id', user.id); // CRITICAL: Only delete if user owns this schedule

   if (error) throw error;
 }

+/**
+ * Delete all bell schedules for a given grade for the current user.
+ */
 export async function deleteGradeSchedules(gradeLevel: string) {
   const supabase = createClientComponentClient<Database>();

   const { data: { user } } = await supabase.auth.getUser();
   if (!user) throw new Error('Not authenticated');

   const { error } = await supabase
     .from('bell_schedules')
     .delete()
     .eq('grade_level', gradeLevel)
     .eq('provider_id', user.id);

   if (error) throw error;
 }

+/**
+ * Fetch all bell schedules owned by the current user ordered for display.
+ */
 export async function getBellSchedules() {
   const supabase = createClientComponentClient<Database>();

   const { data: { user } } = await supabase.auth.getUser();
   if (!user) throw new Error('Not authenticated');

   const { data, error } = await supabase
     .from('bell_schedules')
     .select('*')
     .eq('provider_id', user.id)
     .order('grade_level', { ascending: true })
     .order('day_of_week', { ascending: true })
     .order('start_time', { ascending: true });

   if (error) throw error;
   return data || [];
 }
\ No newline at end of file
diff --git a/lib/supabase/queries/schedule-sessions.ts b/lib/supabase/queries/schedule-sessions.ts
index b10adef65d4606050c7bb4b72273d55949c8bf30..054ffd11d23d90ae4559640ee825013a55759907 100644
--- a/lib/supabase/queries/schedule-sessions.ts
+++ b/lib/supabase/queries/schedule-sessions.ts
@@ -1,28 +1,34 @@
 import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';
 import { Database } from '../../../src/types/database';

+/**
+ * Calculate how many sessions still need to be scheduled this week.
+ *
+ * Combines the required sessions_per_week for each student with the number of
+ * sessions already scheduled to return the remaining count.
+ */
 export async function getUnscheduledSessionsCount() {
   const supabase = createClientComponentClient<Database>();

   const { data: { user } } = await supabase.auth.getUser();
   if (!user) throw new Error('Not authenticated');

   // Get all students and their requirements
   const { data: students } = await supabase
     .from('students')
     .select('id, sessions_per_week')
     .eq('provider_id', user.id);

   if (!students) return 0;

   // Get current scheduled sessions count per student
   const { data: sessions } = await supabase
     .from('schedule_sessions')
     .select('student_id')
     .eq('provider_id', user.id);

   // Count sessions per student
   const sessionCounts = new Map<string, number>();
   sessions?.forEach(session => {
     const count = sessionCounts.get(session.student_id) || 0;
     sessionCounts.set(session.student_id, count + 1);
diff --git a/lib/supabase/queries/special-activities.ts b/lib/supabase/queries/special-activities.ts
index 9076f81caa0eeec27ab46ea557007c3a702083f6..efed796602132957392e6e8c94eb4569f5a5827f 100644
--- a/lib/supabase/queries/special-activities.ts
+++ b/lib/supabase/queries/special-activities.ts
@@ -1,123 +1,138 @@
 import { createClient } from '../../../lib/supabase/client';
 import { SpecialActivity } from '../../../src/types/database';

+/**
+ * Retrieve all special activities belonging to the logged in provider.
+ */
 export async function getSpecialActivities(): Promise<SpecialActivity[]> {
   const supabase = createClient();

   // Get current user first - CRITICAL for security
   const { data: { user }, error: userError } = await supabase.auth.getUser();
   if (userError || !user) {
     throw new Error('User not authenticated');
   }

   const { data, error } = await supabase
     .from('special_activities')
     .select('*')
     .eq('provider_id', user.id) // CRITICAL: Filter by provider_id
     .order('day_of_week')
     .order('start_time');

   if (error) {
     console.error('Error fetching special activities:', error);
     throw error;
   }

   return data || [];
 }

+/**
+ * Add a new special activity for the current provider.
+ */
 export async function addSpecialActivity(
   activity: Omit<SpecialActivity, 'id' | 'created_at' | 'provider_id'>
 ): Promise<SpecialActivity> {
   const supabase = createClient();

   // Get current user
   const { data: { user }, error: userError } = await supabase.auth.getUser();
   if (userError || !user) {
     throw new Error('User not authenticated');
   }

   const { data, error } = await supabase
     .from('special_activities')
     .insert({
       ...activity,
       provider_id: user.id // CRITICAL: Explicitly set provider_id
     })
     .select()
     .single();

   if (error) {
     console.error('Error adding special activity:', error);
     throw error;
   }

   return data;
 }

+/**
+ * Delete a special activity by id after verifying ownership.
+ */
 export async function deleteSpecialActivity(id: string): Promise<void> {
   const supabase = createClient();

   // Get current user
   const { data: { user }, error: userError } = await supabase.auth.getUser();
   if (userError || !user) {
     throw new Error('User not authenticated');
   }

   // CRITICAL: Double-check ownership before delete
   const { error } = await supabase
     .from('special_activities')
     .delete()
     .eq('id', id)
     .eq('provider_id', user.id); // CRITICAL: Ensure user owns this record

   if (error) {
     console.error('Error deleting special activity:', error);
     throw error;
   }
 }

+/**
+ * Remove all activities for a specific teacher owned by the user.
+ */
 export async function deleteTeacherActivities(teacherName: string): Promise<void> {
   const supabase = createClient();

   // Get current user
   const { data: { user }, error: userError } = await supabase.auth.getUser();
   if (userError || !user) {
     throw new Error('User not authenticated');
   }

   const { error } = await supabase
     .from('special_activities')
     .delete()
     .eq('teacher_name', teacherName)
     .eq('provider_id', user.id); // CRITICAL: Filter by provider_id

   if (error) {
     console.error('Error deleting teacher activities:', error);
     throw error;
   }
 }

+/**
+ * Get activities for a specific teacher belonging to the user.
+ */
 export async function getSpecialActivitiesByTeacher(
   teacherName: string
 ): Promise<SpecialActivity[]> {
   const supabase = createClient();

   // Get current user
   const { data: { user }, error: userError } = await supabase.auth.getUser();
   if (userError || !user) {
     throw new Error('User not authenticated');
   }

   const { data, error } = await supabase
     .from('special_activities')
     .select('*')
     .eq('teacher_name', teacherName)
     .eq('provider_id', user.id) // CRITICAL: Filter by provider_id
     .order('day_of_week')
     .order('start_time');

   if (error) {
     console.error('Error fetching teacher activities:', error);
     throw error;
   }

   return data || [];
diff --git a/lib/supabase/queries/students.ts b/lib/supabase/queries/students.ts
index 3f94becc0874fefdd30f2fea1fa4ddcef19ab69b..5faf0d352f8ce41f972250c436f904f3a04c4163 100644
--- a/lib/supabase/queries/students.ts
+++ b/lib/supabase/queries/students.ts
@@ -1,145 +1,160 @@
 import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';

+/**
+ * Create a student record for the logged in provider.
+ */
 export async function createStudent(studentData: {
   initials: string;
   grade_level: string;
   teacher_name: string;
   sessions_per_week: number;
   minutes_per_session: number;
 }) {
   const supabase = createClientComponentClient();

   // Get the current user
   const { data: { user }, error: userError } = await supabase.auth.getUser();

   if (userError || !user) {
     throw new Error('You must be logged in to add students');
   }

   // Try to insert the student
   const { data, error } = await supabase
     .from('students')
     .insert([{
       initials: studentData.initials,
       grade_level: studentData.grade_level.trim(),
       teacher_name: studentData.teacher_name,
       sessions_per_week: studentData.sessions_per_week,
       minutes_per_session: studentData.minutes_per_session,
       provider_id: user.id
     }])
     .select()
     .single();

   if (error) {
     console.error('Detailed Supabase error:', {
       message: error.message,
       details: error.details,
       hint: error.hint,
       code: error.code
     });
     throw new Error(error.message || 'Failed to add student');
   }

   return data;
 }

+/**
+ * Fetch all students owned by the current provider.
+ */
 export async function getStudents() {
   const supabase = createClientComponentClient();

   // Get current user to filter by provider_id
   const { data: { user } } = await supabase.auth.getUser();
   if (!user) throw new Error('No user found');

   const { data, error } = await supabase
     .from('students')
     .select('*')
     .eq('provider_id', user.id)  // Only get current provider's students
     .order('created_at', { ascending: false });

   if (error) throw error;
   return data || [];
 }

+/**
+ * Delete a student and their sessions if the user owns them.
+ */
 export async function deleteStudent(studentId: string) {
   const supabase = createClientComponentClient();

   // CRITICAL: Get current user to verify ownership
   const { data: { user } } = await supabase.auth.getUser();
   if (!user) throw new Error('No user found');

   // CRITICAL: First verify the user owns this student
   const { data: student, error: checkError } = await supabase
     .from('students')
     .select('id')
     .eq('id', studentId)
     .eq('provider_id', user.id)
     .single();

   if (checkError || !student) {
     throw new Error('Student not found or access denied');
   }

   // Delete schedule_sessions for this student (with provider_id check)
   await supabase
     .from('schedule_sessions')
     .delete()
     .eq('student_id', studentId)
     .eq('provider_id', user.id); // CRITICAL: Only delete sessions owned by this provider

   // Then delete the student (with provider_id check)
   const { error } = await supabase
     .from('students')
     .delete()
     .eq('id', studentId)
     .eq('provider_id', user.id); // CRITICAL: Only delete if user owns this student

   if (error) throw error;
 }

+/**
+ * Update a student's session requirements if owned by the user.
+ */
 export async function updateStudent(studentId: string, updates: {
   sessions_per_week: number;
   minutes_per_session: number;
 }) {
   const supabase = createClientComponentClient();

   // CRITICAL: Get current user to verify ownership
   const { data: { user } } = await supabase.auth.getUser();
   if (!user) throw new Error('No user found');

   // Only allow updating sessions_per_week and minutes_per_session
   const { data, error } = await supabase
     .from('students')
     .update({
       sessions_per_week: updates.sessions_per_week,
       minutes_per_session: updates.minutes_per_session
     })
     .eq('id', studentId)
     .eq('provider_id', user.id) // CRITICAL: Only update if user owns this student
     .select()
     .single();

   if (error) {
     if (error.code === 'PGRST116') {
       throw new Error('Student not found or access denied');
     }
     throw error;
   }

   return data;
 }

+/**
+ * Convenience wrapper that creates a student and returns the new record.
+ */
 export async function createStudentWithAutoSchedule(studentData: {
   initials: string;
   grade_level: string;
   teacher_name: string;
   sessions_per_week: number;
   minutes_per_session: number;
 }) {
   const supabase = createClientComponentClient();

   // First create the student as before
   const student = await createStudent(studentData);

   // Return the student - scheduling will be handled by the component
   return student;
 }
\ No newline at end of file
