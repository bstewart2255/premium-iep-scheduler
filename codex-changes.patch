diff --git a/app/(auth)/login/login-form.tsx b/app/(auth)/login/login-form.tsx
index 4c540b37f1fce0ec26d55602d3f2af93a1a2ed7b..19e6a29ece323092ba1976d0f69f0ea5f62188a5 100644
--- a/app/(auth)/login/login-form.tsx
+++ b/app/(auth)/login/login-form.tsx
@@ -1,68 +1,64 @@
 'use client';

 import { useState } from 'react';
 import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';
 import { useRouter } from 'next/navigation';
 import Link from 'next/link';

 export default function LoginForm() {
   const [email, setEmail] = useState('');
   const [password, setPassword] = useState('');
   const [error, setError] = useState('');
   const [loading, setLoading] = useState(false);
   const router = useRouter();
   const supabase = createClientComponentClient();

   const handleSubmit = async (e: React.FormEvent) => {
     e.preventDefault();
     setError('');
     setLoading(true);

     try {
-      console.log('Attempting login with:', email);

       const { data, error } = await supabase.auth.signInWithPassword({
         email,
         password,
       });

-      console.log('Login response:', { data, error });

       if (error) {
         console.error('Login error:', error);
         setError(error.message);
         setLoading(false);
         return;
       }

       if (data?.session) {
-        console.log('Login successful, session:', data.session);
         // Force a hard refresh to ensure auth state is updated
         window.location.href = '/dashboard';
       } else {
-        console.log('No session returned');
         setError('Login failed - no session created');
       }
     } catch (err) {
       console.error('Unexpected error:', err);
       setError('An unexpected error occurred');
     } finally {
       setLoading(false);
     }
   };

   return (
     <form onSubmit={handleSubmit} className="space-y-6">
       {error && (
         <div className="bg-red-50 border border-red-200 text-red-600 px-4 py-3 rounded-lg">
           {error}
         </div>
       )}

       <div>
         <label htmlFor="email" className="block text-sm font-medium text-gray-700">
           Email
         </label>
         <input
           id="email"
           type="email"
diff --git a/app/(dashboard)/dashboard/schedule/page.tsx b/app/(dashboard)/dashboard/schedule/page.tsx
index 33bc28aca958dc560edb399829ef89cdee085275..661b27a0468a89fe40684f940221c1a09454080d 100644
--- a/app/(dashboard)/dashboard/schedule/page.tsx
+++ b/app/(dashboard)/dashboard/schedule/page.tsx
@@ -207,51 +207,50 @@ export default function SchedulePage() {
     const conflicts = new Set<string>();

     for (let day = 1; day <= 5; day++) {
       // Check every 5 minutes from 8 AM to 3 PM minus session duration
       for (
         let minutes = 0;
         minutes <
         (GRID_END_HOUR - GRID_START_HOUR) * 60 - student.minutes_per_session;
         minutes += 5
       ) {
         const hours = Math.floor(minutes / 60) + GRID_START_HOUR;
         const mins = minutes % 60;
         const timeStr = `${hours.toString().padStart(2, "0")}:${mins.toString().padStart(2, "0")}`;

         const hasConflict = await checkSlotConflicts(
           sessionWithStudent,
           day,
           timeStr,
         );
         if (hasConflict) {
           conflicts.add(`${day}-${timeStr}`);
         }
       }
     }

-    console.log("Conflicts found:", conflicts.size);
     setConflictSlots(conflicts);

     e.dataTransfer.effectAllowed = "move";
   };

   // Handle drag end
   const handleDragEnd = () => {
     setDraggedSession(null);
     setConflictSlots(new Set());
     setDragPosition(null);
   };

   // Track the current drag position
   const [dragPosition, setDragPosition] = useState<{
     day: number;
     time: string;
     pixelY: number;
   } | null>(null);

   // Handle drag over (now tracks pixel position)
   const handleDragOver = (e: React.DragEvent, day: number) => {
     e.preventDefault();

     const rect = e.currentTarget.getBoundingClientRect();
     const relativeY = e.clientY - rect.top;
@@ -357,138 +356,115 @@ export default function SchedulePage() {
       .update({
         day_of_week: day,
         start_time: startTimeFormatted,
         end_time: endTimeFormatted,
       })
       .eq("id", sessionId);

     if (error) {
       alert("Failed to move session: " + error.message);
     } else {
       // Refresh the schedule
       fetchData();
     }
   };

   // Fetch all data
   const fetchData = async () => {
     try {
       setLoading(true);
       const {
         data: { user },
       } = await supabase.auth.getUser();
       if (!user) throw new Error("No user found");
       setCurrentUserId(user.id);

-      console.log("Fetching data for user:", user.id);

       const { data: profile } = await supabase
         .from("profiles")
         .select("role")
         .eq("id", user.id)
         .single();

       if (profile) {
         setProviderRole(profile.role);
-        console.log("Provider role:", profile.role);
       }

       // Fetch SEA profiles if user is Resource Specialist
       if (profile?.role === 'resource') {
         // First get the RS's school info
         const { data: rsProfile } = await supabase
           .from('profiles')
           .select('school_district, school_site')
           .eq('id', user.id)
           .single();

         if (rsProfile) {
           // Find all SEAs in the same school and district
           const { data: seasData } = await supabase
             .from('profiles')
             .select('id, full_name')
             .eq('role', 'sea')
             .eq('school_district', rsProfile.school_district)
             .eq('school_site', rsProfile.school_site);

           if (seasData) {
             setSeaProfiles(seasData);
           }
         }
       }

       const [studentsData, bellData, activitiesData, sessionsData] =
         await Promise.all([
           supabase.from("students").select("*").eq("provider_id", user.id),
           supabase
             .from("bell_schedules")
             .select("*")
             .eq("provider_id", user.id),
           supabase
             .from("special_activities")
             .select("*")
             .eq("provider_id", user.id),
           supabase
             .from("schedule_sessions")
             .select("*")
             .eq("provider_id", user.id),
         ]);

-      console.log("Fetched data:", {
-        students: studentsData.data?.length || 0,
-        bellSchedules: bellData.data?.length || 0,
-        specialActivities: activitiesData.data?.length || 0,
-        sessions: sessionsData.data?.length || 0,
-        sessionDetails: sessionsData.data,
-      });

       if (studentsData.data) setStudents(studentsData.data);
       if (bellData.data) setBellSchedules(bellData.data);
       if (activitiesData.data) setSpecialActivities(activitiesData.data);
       if (sessionsData.data) setSessions(sessionsData.data);

       // Debug: Count sessions per student
       const sessionsByStudent = new Map<string, number>();
       sessionsData.data?.forEach((session) => {
         const count = sessionsByStudent.get(session.student_id) || 0;
         sessionsByStudent.set(session.student_id, count + 1);
       });

-      console.log("Sessions per student:");
-      sessionsByStudent.forEach((count, studentId) => {
-        const student = studentsData.data?.find((s) => s.id === studentId);
-        console.log(`${student?.initials || studentId}: ${count} sessions`);
-      });
-      console.log("All sessions with times:");
-      sessionsData.data?.forEach((session) => {
-        const student = studentsData.data?.find(
-          (s) => s.id === session.student_id,
-        );
-        console.log(
-          `${student?.initials}: Day ${session.day_of_week}, ${session.start_time} - ${session.end_time}`,
-        );
-      });
     } catch (error) {
       console.error("Error fetching data:", error);
     } finally {
       setLoading(false);
     }
   };

   useEffect(() => {
     fetchData();
   }, []);

   // Add this after the existing useEffect
   const [unscheduledCount, setUnscheduledCount] = useState(0);

   // Check for unscheduled sessions
   const checkUnscheduledSessions = async () => {
     try {
       const { getUnscheduledSessionsCount } = await import(
         "../../../../lib/supabase/queries/schedule-sessions"
       );
       const count = await getUnscheduledSessionsCount();
       setUnscheduledCount(count);
     } catch (error) {
       console.error("Error checking unscheduled sessions:", error);
     }
diff --git a/app/components/bell-schedules/csv-import.tsx b/app/components/bell-schedules/csv-import.tsx
index 569ef943e61340af67013beb662b26f2e053b4ef..b556102419f9dcd087710c738645e1dd6eda52ca 100644
--- a/app/components/bell-schedules/csv-import.tsx
+++ b/app/components/bell-schedules/csv-import.tsx
@@ -24,96 +24,88 @@ K,Recess,10:00,10:15
 4,Library,14:00,14:45
 5,Music,09:00,09:45`;

     const blob = new Blob([csvContent], { type: 'text/csv' });
     const url = window.URL.createObjectURL(blob);
     const a = document.createElement('a');
     a.href = url;
     a.download = 'Bell_Schedule_Template.csv';
     a.click();
     window.URL.revokeObjectURL(url);
   };

   const validateColumns = (data: any[]) => {
     if (!data || data.length === 0) return false;
     const firstRow = data[0];
     const headers = Object.keys(firstRow).map(h => h.toLowerCase().trim());

     const requiredColumns = ['grade', 'activity', 'start time', 'end time'];
     const missing = requiredColumns.filter(col => {
       const colLower = col.toLowerCase();
       return !headers.some(header => 
         header === colLower || 
         header.replace(/\s+/g, '') === colLower.replace(/\s+/g, '')
       );
     });
-
-    if (missing.length > 0) {
-      console.log('Missing columns:', missing);
-      console.log('Found headers:', headers);
-    }
-
     return missing.length === 0;
   };

   const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
     const file = e.target.files?.[0];
     if (!file) return;

     setError('');
     setImporting(true);

     try {
       const { data: user } = await supabase.auth.getUser();
       if (!user.user) throw new Error('Not authenticated');

       Papa.parse(file, {
         header: true,
         skipEmptyLines: true,
         transformHeader: (header) => header.trim().toLowerCase(),
         complete: async (results) => {
-          console.log('Parsed data:', results.data);
           try {
             if (!validateColumns(results.data)) {
               throw new Error('CSV missing required columns. Expected: Grade, Activity, Start Time, End Time');
             }

             const schedules = results.data
               .filter((row: any) => row.grade && row.activity)
               .flatMap((row: any) => {
                 // Create entries for each day of the week (Monday-Friday)
                 return [1, 2, 3, 4, 5].map(dayNum => ({
                   provider_id: user.user!.id,
                   grade_level: row.grade.toString().toUpperCase().trim(),
                   period_name: row.activity,
                   day_of_week: dayNum,
                   start_time: row['start time'] + ':00', // Add seconds if missing
                   end_time: row['end time'] + ':00'
                 }));
               });

-            console.log('Schedules to insert:', schedules);

             if (schedules.length > 0) {
               const { error: insertError } = await supabase
                 .from('bell_schedules')
                 .insert(schedules);

               if (insertError) {
                 console.error('Insert error:', insertError);
                 throw insertError;
               }

               alert(`Successfully imported ${schedules.length / 5} bell schedules (applied to all weekdays)!`);
               onSuccess();
             } else {
               throw new Error('No valid schedules found in CSV');
             }
           } catch (err: any) {
             console.error('Import error:', err);
             setError(err.message);
           } finally {
             setImporting(false);
           }
         },
         error: (err) => {
           setError(`CSV parsing error: ${err.message}`);
diff --git a/app/components/schedule/reschedule-all.tsx b/app/components/schedule/reschedule-all.tsx
index 865a5acf476edf356565f7f281650b44e5bd4329..0e3aff9ffa84e6daccdfe884fb815e3ed89fede2 100644
--- a/app/components/schedule/reschedule-all.tsx
+++ b/app/components/schedule/reschedule-all.tsx
@@ -36,51 +36,50 @@ Continue?`;
       const { data: { user } } = await supabase.auth.getUser();
       if (!user) throw new Error('Not authenticated');

       // Save snapshot before making changes
       await saveScheduleSnapshot(user.id);

       // Clear all existing sessions
       const { error: deleteError } = await supabase
         .from('schedule_sessions')
         .delete()
         .eq('provider_id', user.id);

       if (deleteError) throw deleteError;

       // Get all students
       const { data: allStudents } = await supabase
         .from('students')
         .select('*')
         .eq('provider_id', user.id);

       if (!allStudents || allStudents.length === 0) {
         alert('No students found to schedule');
         return;
       }

-      console.log(`Rescheduling ${allStudents.length} students`);

       // Schedule all students
       const results = await scheduleBatchStudents(allStudents);

       alert(`Rescheduling complete!\n\nScheduled: ${results.totalScheduled} students\nFailed: ${results.totalFailed} students${
         results.errors.length > 0 ? '\n\nErrors:\n' + results.errors.slice(0, 5).join('\n') : ''
       }`);

       // Call onComplete callback if provided
       if (onComplete) {
         onComplete();
       } else {
         // Refresh the page to show new sessions
         window.location.reload();
       }
     } catch (error) {
       console.error('Error in rescheduling:', error);
       alert('Failed to reschedule: ' + error.message);
     } finally {
       setIsProcessing(false);
     }
   };

   return (
     <Button
diff --git a/app/components/schedule/schedule-new-sessions.tsx b/app/components/schedule/schedule-new-sessions.tsx
index 4ffed24d11a88a02a7dc775329df678348f593a9..953275c384f449fba588fdec516c9c970296dbcc 100644
--- a/app/components/schedule/schedule-new-sessions.tsx
+++ b/app/components/schedule/schedule-new-sessions.tsx
@@ -48,51 +48,50 @@ Continue?`;
       }

       // Get existing sessions to determine which students need scheduling
       const { data: existingSessions } = await supabase
         .from('schedule_sessions')
         .select('student_id')
         .eq('provider_id', user.id);

       // Count sessions per student
       const sessionCounts = existingSessions?.reduce((acc, session) => {
         acc[session.student_id] = (acc[session.student_id] || 0) + 1;
         return acc;
       }, {} as Record<string, number>) || {};

       // Filter students who need scheduling
       const studentsNeedingScheduling = allStudents.filter(student => {
         const currentSessions = sessionCounts[student.id] || 0;
         return currentSessions < student.sessions_per_week;
       });

       if (studentsNeedingScheduling.length === 0) {
         alert('All students are fully scheduled!');
         return;
       }

-      console.log(`Found ${studentsNeedingScheduling.length} students needing scheduling`);

       // Save snapshot before making changes
       await saveScheduleSnapshot(user.id);

       // Schedule only these students
       const results = await scheduleBatchStudents(studentsNeedingScheduling);

       alert(`Scheduling complete!\n\nScheduled: ${results.totalScheduled} students\nFailed: ${results.totalFailed} students${
         results.errors.length > 0 ? '\n\nErrors:\n' + results.errors.slice(0, 5).join('\n') : ''
       }`);

       // Call onComplete callback if provided
       if (onComplete) {
         onComplete();
       } else {
         // Refresh the page to show new sessions
         window.location.reload();
       }
     } catch (error) {
       console.error('Error in scheduling new sessions:', error);
       alert('Failed to schedule new sessions: ' + error.message);
     } finally {
       setIsProcessing(false);
     }
   };
diff --git a/app/components/schedule/undo-schedule.tsx b/app/components/schedule/undo-schedule.tsx
index e00162220ed6d83c7107b8a381666890d306e79b..8d94f5812e49335576b2501983744ee22f8c9f51 100644
--- a/app/components/schedule/undo-schedule.tsx
+++ b/app/components/schedule/undo-schedule.tsx
@@ -141,31 +141,30 @@ Continue?`;
       </svg>
       )}
     </Button>
   );
 }

 // Helper function to save current schedule snapshot
 export async function saveScheduleSnapshot(providerId: string) {
   const supabase = createClientComponentClient();

   try {
     // Get all current sessions
     const { data: sessions, error } = await supabase
       .from('schedule_sessions')
       .select('*')
       .eq('provider_id', providerId);

     if (error) throw error;

     // Save to localStorage
     const snapshot = {
       timestamp: new Date().toISOString(),
       sessions: sessions || []
     };

-    localStorage.setItem('scheduleSnapshot', JSON.stringify(snapshot));
-    console.log(`Saved snapshot with ${sessions?.length || 0} sessions`);
+  localStorage.setItem('scheduleSnapshot', JSON.stringify(snapshot));
   } catch (error) {
     console.error('Error saving schedule snapshot:', error);
   }
 }
\ No newline at end of file
diff --git a/app/components/special-activities/csv-import.tsx b/app/components/special-activities/csv-import.tsx
index 4bc2172cb72b72041cbdf5889308467b5061da73..b99fe22ae8243c782eeb03519dcec58d2f04d12e 100644
--- a/app/components/special-activities/csv-import.tsx
+++ b/app/components/special-activities/csv-import.tsx
@@ -25,102 +25,94 @@ Garcia,Computer Lab,Friday,14:00,14:45`;
     const blob = new Blob([csvContent], { type: 'text/csv' });
     const url = window.URL.createObjectURL(blob);
     const a = document.createElement('a');
     a.href = url;
     a.download = 'Special_Activities_Template.csv';
     a.click();
     window.URL.revokeObjectURL(url);
   };

   const dayNameToNumber = (dayName: string): number => {
     const days: { [key: string]: number } = {
       'monday': 1,
       'tuesday': 2,
       'wednesday': 3,
       'thursday': 4,
       'friday': 5
     };
     return days[dayName.toLowerCase().trim()] || 1;
   };

   const validateColumns = (data: any[]) => {
     if (!data || data.length === 0) return false;
     const firstRow = data[0];
     const headers = Object.keys(firstRow).map(h => h.toLowerCase().trim());

-    console.log('Headers found:', headers);

     const requiredColumns = ['teacher', 'activity', 'day', 'start time', 'end time'];
     const missing = requiredColumns.filter(col => {
       const colLower = col.toLowerCase();
       return !headers.some(header => 
         header === colLower || 
         header.replace(/\s+/g, '') === colLower.replace(/\s+/g, '')
       );
     });
-
-    if (missing.length > 0) {
-      console.log('Missing columns:', missing);
-    }
-
     return missing.length === 0;
   };

   const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
     const file = e.target.files?.[0];
     if (!file) return;

     setError('');
     setImporting(true);

     try {
       const { data: user } = await supabase.auth.getUser();
       if (!user.user) throw new Error('Not authenticated');

       Papa.parse(file, {
         header: true,
         skipEmptyLines: true,
         transformHeader: (header) => header.trim().toLowerCase(),
         complete: async (results) => {
-          console.log('Parsed data:', results.data);
           try {
             if (!validateColumns(results.data)) {
               throw new Error('CSV missing required columns. Expected: Teacher, Activity, Day, Start Time, End Time');
             }

             const activities = results.data
               .filter((row: any) => row.teacher && row.activity && row.day)
               .map((row: any) => ({
                 provider_id: user.user!.id,
                 teacher_name: row.teacher,
                 activity_name: row.activity,
                 day_of_week: dayNameToNumber(row.day),
                 start_time: row['start time'] + ':00', // Add seconds if missing
                 end_time: row['end time'] + ':00'
               }));

-            console.log('Activities to insert:', activities);

             if (activities.length > 0) {
               const { error: insertError } = await supabase
                 .from('special_activities')
                 .insert(activities);

               if (insertError) {
                 console.error('Insert error:', insertError);
                 throw insertError;
               }

               alert(`Successfully imported ${activities.length} special activities!`);
               onSuccess();
             } else {
               throw new Error('No valid activities found in CSV');
             }
           } catch (err: any) {
             console.error('Import error:', err);
             setError(err.message);
           } finally {
             setImporting(false);
           }
         },
         error: (err) => {
           setError(`CSV parsing error: ${err.message}`);
diff --git a/app/components/students/add-student-form.tsx b/app/components/students/add-student-form.tsx
index 0ee47448c0d3346c21bacdc6c6f047347513f71f..76ffa8c828d49641772ecf05a427a8720ff7d5fd 100644
--- a/app/components/students/add-student-form.tsx
+++ b/app/components/students/add-student-form.tsx
@@ -5,62 +5,60 @@
   import { Button } from '../ui/button';
   import { Label, Input, Select, FormGroup, FormSection, HelperText, ErrorMessage } from '../ui/form';

   interface AddStudentFormProps {
     onClose: () => void;
     onSuccess: () => void;
   }

   export function AddStudentForm({ onClose, onSuccess }: AddStudentFormProps) {
     const [formData, setFormData] = useState({
       initials: '',
       grade_level: '',
       teacher_name: '',
       sessions_per_week: 1,
       minutes_per_session: 30,
     });
     const [loading, setLoading] = useState(false);
     const [error, setError] = useState('');

     const handleSubmit = async (e: React.FormEvent) => {
       e.preventDefault();
       setError('');
       setLoading(true);

       try {
-        console.log('Creating student with data:', formData);

         // Create the student
         const student = await createStudent({
           initials: formData.initials.toUpperCase(),
           grade_level: formData.grade_level.trim(),
           teacher_name: formData.teacher_name,
           sessions_per_week: formData.sessions_per_week,
           minutes_per_session: formData.minutes_per_session,
         });

-        console.log('Student created:', student);

         // Show success message with scheduling reminder
         alert(`Student "${student.initials}" has been added successfully!\n\nReminder: Go to the Schedule page and click "Re-schedule All Sessions" to schedule their sessions.`);

         onSuccess();
         onClose();
       } catch (err) {
         console.error('Error adding student:', err);
         setError(err instanceof Error ? err.message : 'Failed to add student');
       } finally {
         setLoading(false);
       }
     };

   return (
   <form onSubmit={handleSubmit} className="space-y-4">
     <FormSection title="Student Information" description="Enter the student's details below">
       <FormGroup>
         <Label htmlFor="initials" required>
           Student Initials
         </Label>
         <Input
           id="initials"
           type="text"
           value={formData.initials}
diff --git a/app/components/students/csv-import.tsx b/app/components/students/csv-import.tsx
index a20ddeb6278f37f868ea314e0aad99838c8df261..28588fccfd8f42f79faa6cdfe1aa3dda93364458 100644
--- a/app/components/students/csv-import.tsx
+++ b/app/components/students/csv-import.tsx
@@ -22,93 +22,85 @@ CD,5,Davis,1,45
 EF,2,Wilson,2,30
 GH,4,Garcia,3,30`;

     const blob = new Blob([csvContent], { type: 'text/csv' });
     const url = window.URL.createObjectURL(blob);
     const a = document.createElement('a');
     a.href = url;
     a.download = 'Students_Template.csv';
     a.click();
     window.URL.revokeObjectURL(url);
   };

   const validateColumns = (data: any[]) => {
     if (!data || data.length === 0) return false;
     const firstRow = data[0];
     const headers = Object.keys(firstRow).map(h => h.toLowerCase().trim());

     const requiredColumns = ['initials', 'grade', 'teacher', 'sessions per week', 'minutes per session'];
     const missing = requiredColumns.filter(col => {
       const colLower = col.toLowerCase();
       return !headers.some(header => 
         header === colLower || 
         header.replace(/\s+/g, '') === colLower.replace(/\s+/g, '')
       );
     });
-
-    if (missing.length > 0) {
-      console.log('Missing columns:', missing);
-      console.log('Found headers:', headers);
-    }
-
-    return missing.length === 0;
+  return missing.length === 0;
   };

   const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
     const file = e.target.files?.[0];
     if (!file) return;

     setError('');
     setImporting(true);

     try {
       const { data: user } = await supabase.auth.getUser();
       if (!user.user) throw new Error('Not authenticated');

       Papa.parse(file, {
         header: true,
         skipEmptyLines: true,
         transformHeader: (header) => header.trim().toLowerCase(),
         complete: async (results) => {
-          console.log('Parsed data:', results.data);
           try {
             if (!validateColumns(results.data)) {
               throw new Error('CSV missing required columns. Expected: Initials, Grade, Teacher, Sessions Per Week, Minutes Per Session');
             }

             const students = results.data
               .filter((row: any) => row.initials && row.grade && row.teacher)
               .map((row: any) => ({
                 provider_id: user.user!.id,
                 initials: row.initials.toUpperCase().trim(),
                 grade_level: row.grade.toString().toUpperCase().trim(),
                 teacher_name: row.teacher.trim(),
                 sessions_per_week: parseInt(row['sessions per week']) || 2,
                 minutes_per_session: parseInt(row['minutes per session']) || 30
               }));

-            console.log('Students to insert:', students);

             if (students.length > 0) {
               const { error: insertError } = await supabase
                 .from('students')
                 .insert(students);

               if (insertError) {
                 console.error('Insert error:', insertError);
                 throw insertError;
               }

               alert(`Successfully imported ${students.length} students!`);
               onSuccess();
             } else {
               throw new Error('No valid students found in CSV');
             }
           } catch (err: any) {
             console.error('Import error:', err);
             setError(err.message);
           } finally {
             setImporting(false);
           }
         },
         error: (err) => {
           setError(`CSV parsing error: ${err.message}`);
diff --git a/app/components/ui/modal.tsx b/app/components/ui/modal.tsx
index c089df02bcce59d2afe0a95e062ea453a69022e3..c06e85457e5932a2a2e5da19050c4d6d8042593c 100644
--- a/app/components/ui/modal.tsx
+++ b/app/components/ui/modal.tsx
@@ -1,37 +1,36 @@
 'use client';
 import { useEffect } from 'react';

 interface ModalProps {
   isOpen: boolean;
   onClose: () => void;
   title: string;
   children: React.ReactNode;
 }

 export function Modal({ isOpen, onClose, title, children }: ModalProps) {
-  console.log('Modal rendered, isOpen:', isOpen);

   // Add escape key handler and body scroll prevention
   useEffect(() => {
     const handleEscape = (e: KeyboardEvent) => {
       if (e.key === 'Escape' && isOpen) {
         onClose();
       }
     };

     if (isOpen) {
       document.addEventListener('keydown', handleEscape);
       document.body.style.overflow = 'hidden';
     }

     return () => {
       document.removeEventListener('keydown', handleEscape);
       document.body.style.overflow = 'unset';
     };
   }, [isOpen, onClose]);

   if (!isOpen) return null;

   return (
     <div className="fixed inset-0 z-50 overflow-y-auto">
       {/* Backdrop - moved outside flex container for better layering */}
diff --git a/lib/scheduling/auto-scheduler.ts b/lib/scheduling/auto-scheduler.ts
index 96245105470f3888bc32b60730d1d121b2f91d58..d87cfa247d06e19ee6fb293151c53efb19e355e8 100644
--- a/lib/scheduling/auto-scheduler.ts
+++ b/lib/scheduling/auto-scheduler.ts
@@ -54,131 +54,125 @@ export class AutoScheduler {
         sessionDuration,
         sessionsNeeded,
         existingSessions,
         bellSchedules,
         specialActivities
       );

       if (availableSlots.length < sessionsNeeded) {
         result.unscheduledStudents.push(student);
         result.errors.push(`Could only find ${availableSlots.length} of ${sessionsNeeded} required slots for ${student.initials}`);
       }

       // Create session objects for the available slots
       for (let i = 0; i < Math.min(availableSlots.length, sessionsNeeded); i++) {
         const slot = availableSlots[i];
         result.scheduledSessions.push({
           student_id: student.id,
           provider_id: this.providerId,
           day_of_week: slot.dayOfWeek,
           start_time: slot.startTime,
           end_time: slot.endTime,
           service_type: this.providerRole
         });
       }

-      console.log(`Created ${result.scheduledSessions.length} sessions for ${student.initials}`);

       result.success = result.scheduledSessions.length === sessionsNeeded;
     } catch (error) {
       result.errors.push(`Error scheduling ${student.initials}: ${error.message}`);
     }

     return result;
   }

   // Find available time slots for a student
   private async findAvailableSlots(
     student: Student,
     duration: number,
     slotsNeeded: number,
     existingSessions: ScheduleSession[],
     bellSchedules: BellSchedule[],
     specialActivities: SpecialActivity[]
   ): Promise<ScheduleSlot[]> {
-    console.log(`Finding ${slotsNeeded} slots of ${duration} minutes for student ${student.initials}`);

     const availableSlots: ScheduleSlot[] = [];
     const days = [1, 2, 3, 4, 5]; // Monday through Friday
     const timeSlots = this.generateTimeSlots();
     const scheduledForThisStudent: ScheduleSlot[] = [];

     // Try to distribute sessions across days evenly
     const sessionsByDay = this.countSessionsByDay(existingSessions);
     const sortedDays = days.sort((a, b) => (sessionsByDay[a] || 0) - (sessionsByDay[b] || 0));

     // NEW: Rotate through different starting times to distribute throughout the day
     let timeSlotStartIndex = existingSessions.length % timeSlots.length;

     // Simple single pass - one session per day rule makes this much simpler
     for (const day of sortedDays) {
       if (availableSlots.length >= slotsNeeded) break;

       // Check if we already scheduled this student today
       const alreadyScheduledToday = scheduledForThisStudent.some(slot => slot.dayOfWeek === day);
       if (alreadyScheduledToday) {
-        console.log(`Already scheduled on day ${day}, skipping`);
         continue;
       }

       // Start from different time slots to distribute throughout the day
       for (let i = 0; i < timeSlots.length; i++) {
         const timeIndex = (timeSlotStartIndex + i) % timeSlots.length;
         const startTime = timeSlots[timeIndex];
         const endTime = this.addMinutesToTime(startTime, duration);

         // Check if this slot is valid
         const validation = this.validateSlot(
           student,
           day,
           startTime,
           endTime,
           duration,
           existingSessions,
           bellSchedules,
           specialActivities,
           scheduledForThisStudent
         );

         if (validation.valid) {
           const newSlot = {
             dayOfWeek: day,
             startTime,
             endTime
           };
           availableSlots.push(newSlot);
           scheduledForThisStudent.push(newSlot);
-          console.log(`Found valid slot: Day ${day}, ${startTime}-${endTime}`);
           break; // Move to next day after finding one slot
         } else {
-          console.log(`Invalid slot: Day ${day}, ${startTime}-${endTime} - Reason: ${validation.reason}`);
         }
       }
     }

     if (availableSlots.length < slotsNeeded) {
-      console.log(`Only found ${availableSlots.length} of ${slotsNeeded} required slots`);
     }

     return availableSlots;
   }

   // Utility functions
   private generateTimeSlots(): string[] {
     const slots: string[] = [];
     // Generate slots every 5 minutes for maximum flexibility
     for (let hour = 8; hour <= 14; hour++) {
       for (let minute = 0; minute < 60; minute += 5) {
         // Don't go past 2:30 PM to leave buffer before 3 PM
         if (hour === 14 && minute > 30) break;
         slots.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
       }
     }
     return slots;
   }

   private timeToMinutes(time: string): number {
     const [hours, minutes] = time.split(':').map(Number);
     return hours * 60 + minutes;
   }

   private addMinutesToTime(time: string, minutesToAdd: number): string {
@@ -194,51 +188,50 @@ export class AutoScheduler {
     const start2Min = this.timeToMinutes(start2);
     const end2Min = this.timeToMinutes(end2);

     return !(end1Min <= start2Min || start1Min >= end2Min);
   }

   private countSessionsByDay(sessions: ScheduleSession[]): Record<number, number> {
     const counts: Record<number, number> = {};
     sessions.forEach(session => {
       counts[session.day_of_week] = (counts[session.day_of_week] || 0) + 1;
     });
     return counts;
   }

   private validateSlot(
     student: Student,
     dayOfWeek: number,
     startTime: string,
     endTime: string,
     duration: number,
     existingSessions: ScheduleSession[],
     bellSchedules: BellSchedule[],
     specialActivities: SpecialActivity[],
     scheduledForThisStudent: ScheduleSlot[] = []
   ): { valid: boolean; reason?: string } {
-    console.log(`Validating slot for ${student.initials}: Day ${dayOfWeek}, ${startTime}-${endTime} (${duration} min)`);

     // Check if session fits within school hours (before 3:00 PM)
     if (this.timeToMinutes(endTime) > this.timeToMinutes('15:00')) {
       return { valid: false, reason: 'Extends beyond school hours' };
     }

     // Check bell schedule conflicts
     const bellConflicts = bellSchedules.filter(bell => {
       const grades = bell.grade_level.split(',').map(g => g.trim());
       return grades.includes(student.grade_level.trim()) &&
              bell.day_of_week === dayOfWeek &&
              this.hasTimeOverlap(startTime, endTime, bell.start_time, bell.end_time);
     });

     if (bellConflicts.length > 0) {
       return { valid: false, reason: `Conflicts with ${bellConflicts[0].period_name}` };
     }

     // Check special activity conflicts
     const activityConflicts = specialActivities.filter(activity =>
       activity.teacher_name === student.teacher_name &&
       activity.day_of_week === dayOfWeek &&
       this.hasTimeOverlap(startTime, endTime, activity.start_time, activity.end_time)
     );

diff --git a/lib/supabase/hooks/use-auto-schedule.ts b/lib/supabase/hooks/use-auto-schedule.ts
index 0b3f4977f41ac971348e54ae4cb0b4cd1b2401bf..1b5e8afe08a3518bfd075f6e6103c8540efe8594 100644
--- a/lib/supabase/hooks/use-auto-schedule.ts
+++ b/lib/supabase/hooks/use-auto-schedule.ts
@@ -43,51 +43,50 @@ export function useAutoSchedule() {
           .eq('provider_id', user.id)
       ]);

       const existingSessions = sessionsData.data || [];
       const bellSchedules = bellData.data || [];
       const specialActivities = activitiesData.data || [];

       // Create scheduler instance
       const scheduler = new AutoScheduler(user.id, profile.role);

       // Schedule the student
       const result = await scheduler.scheduleStudent(
         student,
         existingSessions,
         bellSchedules,
         specialActivities
       );

       // Save the scheduled sessions to database
       if (result.scheduledSessions.length > 0) {
         const { error: insertError } = await supabase
           .from('schedule_sessions')
           .insert(result.scheduledSessions);

         if (insertError) throw insertError;
-        console.log(`Successfully saved sessions for ${student.initials}`);
       }

       // Set any errors
       if (result.errors.length > 0) {
         setSchedulingErrors(result.errors);
       }

       return result;
     } catch (error) {
       console.error('Auto-scheduling error:', error);
       setSchedulingErrors([error.message]);
       return {
         success: false,
         scheduledSessions: [],
         unscheduledStudents: [student],
         errors: [error.message]
       };
     } finally {
       setIsScheduling(false);
     }
   };

   const scheduleBatchStudents = async (students: Student[]) => {
     setIsScheduling(true);
     setSchedulingErrors([]);
@@ -119,62 +118,58 @@ export function useAutoSchedule() {
         // Fetch fresh data for each student to include previously scheduled sessions
         const [sessionsData, bellData, activitiesData] = await Promise.all([
           supabase
             .from('schedule_sessions')
             .select('*')
             .eq('provider_id', user.id),
           supabase
             .from('bell_schedules')
             .select('*')
             .eq('provider_id', user.id),
           supabase
             .from('special_activities')
             .select('*')
             .eq('provider_id', user.id)
         ]);

         const result = await scheduler.scheduleStudent(
           student,
           sessionsData.data || [],
           bellData.data || [],
           activitiesData.data || []
         );

         // Save scheduled sessions
         if (result.scheduledSessions.length > 0) {
-          console.log(`Attempting to save ${result.scheduledSessions.length} sessions for ${student.initials}`);
-          console.log('Sessions to save:', result.scheduledSessions);

           const { error: insertError } = await supabase
             .from('schedule_sessions')
             .insert(result.scheduledSessions);

           if (!insertError) {
-            console.log(`Successfully saved ${result.scheduledSessions.length} sessions for ${student.initials}`);
             results.totalScheduled++;
           } else {
-            console.log(`Error saving sessions for ${student.initials}:`, insertError);
             results.totalFailed++;
             results.errors.push(`Failed to save sessions for ${student.initials}: ${insertError.message}`);
           }
         } else {
           results.totalFailed++;
         }

         // Collect errors
         results.errors.push(...result.errors);
       }

       setSchedulingErrors(results.errors);
       return results;
     } catch (error) {
       console.error('Batch scheduling error:', error);
       setSchedulingErrors([error.message]);
       return {
         totalScheduled: 0,
         totalFailed: students.length,
         errors: [error.message]
       };
     } finally {
       setIsScheduling(false);
     }
   };
